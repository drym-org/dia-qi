* Qi (100%)
	* Initial work / foundation (40%)
		* The language was designed (30%)
		* The initial implementation was written (70%)
	* Promotion / getting the word out / community (5%)
		* The initial author was invited to give a talk at RacketCon (7%)
		* The initial author received feedback on drafts of the talk (7%)
		* The initial author gave a talk at RacketCon (10%)
		* A Q&A was held after the talk (5%)
		* An early adopter advocated for the project (7%)
		* An early adopter advocated for the project (7%)
		* An early adopter advocated for the project (7%)
		* Advent of Code was solved using Qi (7%)
		* The idea of a Qi-themed event was suggested (5%)
		* The Qi design challenge was organized (7%)
		* A weekly meetup for the project was started (7%)
		* The project benefited from general support from the Racket community (5%)
		* The first library extending Qi functionality was written (7%)
		* There was a suggestion to write a tutorial (5%)
		* An interactive tutorial was written using racket templates (7%)
	* Documentation (15%)
		* A quickscript for interactive evaluation in DrRacket was added to support the Qi tutorial (10%)
		* A broken link in the documentation was reported (3%)
		* There was a suggestion to create a wiki for Qi (4%)
		* The wiki was created (10%)
		* A Developer's Guide containing developer documentation was written (30%)
		* Documentation was written for Qi (40%)
		* Some formatting and typos in the docs were fixed (3%)
	* Improving usability / ease of adoption: (5%)
		* Racket templates (40%)
			* There was a suggestion to distribute a Qi template using racket templates (10%)
			* There was a suggestion to decompose the package into lib/test/doc packages for more flexible development and distribution (10%)
			* The package was decomposed into lib/test/doc packages (70%)
			* An installation issue was reported (10%)
		* IDE support (40%)
			* A quickscript for entering unicode in DrRacket was written (50%)
			* A flow-oriented debugger was added (50%)
		* The package config was modified so that Qi appears in the languages section of the docs (3%)
		* CI was set up for the project repository (10%)
		* A recipe for hosting backup documentation in case the package index is unavailable was provided (3%)
		* The backup docs workflow following the recipe was added (3%)
		* The repo was migrated to an organization account (1%)
	* Implementation (30%)
		* The core macro was refactored into separate expansion and compilation stages (35%)
		* Macro extensibility (35%)
			* A simple macro extensibility based on prefix matching was designed, to allow users to extend the syntax of the language in a rudimentary way (20%)
			* An implementation for the prefix matching macro extensibility scheme was provided (20%)
			* Many options for proper macro extensibility were suggested (10%)
			* "First class" macro extensibility was implemented, allowing users to seamlessly extend the syntax of the language (50%)
		* Form improvements (20%)
			* Switch form (15%)
				* Improvements to the switch form were suggested (25%)
				* Improvements to switch were implemented (50%)
				* Some bugs in switch were fixed (25%)
			* Clos form (15%)
				* A design example was provided to motivate adding closures (the clos form) to Qi (30%)
				* The name clos was suggested for this form (70%)
			* Threading form error message (10%)
				* A confusing error message in the threading form was reported and a way to handle it was suggested (20%)
				* The suggested error message fix was implemented (20%)
				* Threading form bug (20%)
				* An elusive bug was identified that was causing performance degradation in the threading form (20%)
				* A hygiene issue related to the same bug was identified that could have caused other bugs in the future (20%)
			* Feedback form design improvements (15%)
				* An example implementation to motivate design improvements in feedback was provided (40%)
				* The design of feedback was improved (40%)
				* The feedback PR was reviewed (20%)
			* Restricting fancy-app (10%)
				* There was a suggestion to restrict fancy-app's (a templatized function application library) scope in Qi to avoid tricky bugs in handling user input (40%)
				* fancy-app was restricted to just the fine-grained application form (40%)
				* The fancy-app PR was reviewed (20%)
			* Optimizing fanout (10%)
				* It was pointed out that fanout does not accept arbitrary Racket expressions for N (10%)
				* An optimized implementation was suggested for fanout (35%)
				* fanout was modified to support arbitrary expressions for N and have an optimized implementation (35%)
				* The fanout PR was reviewed (20%)
			* Partition (15%)
				* partition was added, which is a generalized version of the sieve form (80%)
				* The partition PR was reviewed (20%)
			* The ability to support the _ template in the function position was added (5%)
			* Support for keyword arguments to add bindings in lambda forms of the language was added (5%)
		* Reducing tech debt (10%)
			* Uses of deprecated macro form ~or were updated to ~or* (40%)
			* The unused let/flow and let/switch macros were removed (40%)
			* The organization of some tests was improved (20%)
	* Operational excellence (5%)
		* Performance (60%)
			* The partition implementation was optimized (15%)
			* Benchmarking scripts were added (13%)
			* The performance benchmarks were audited for accuracy (12%)
			* The benchmarks were fixed according to the audit (10%)
			* The number of dependencies was reduced (10%)
			* These tools were used to identify and remove all heavy dependencies and dramatically reduce load-time latency (15%)
			* The performance of any?, all?, and none? were significantly improved (15%)
			* There was a suggestion to use indirect documentation links to reduce build times (5%)
			* Some improvements were suggested to reduce memory consumption in building docs (5%)
		* Dev Tools (40%)
			* CI was set up for the project repository (25%)
			* Performance benchmarking was added to CI (25%)
			* A dependency profiler tool was written to identify heavy dependencies (15%)
			* A way to measure load-time latency was suggested (5%)
			* A script to measure load-time latency following that approach was written (12%)
			* The load-time latency PR was reviewed (8%)
			* The benchmarks runner config was modified to avoid reporting success when it failed (10%)

Notes:
- Initial work + Implementation = 70% = Symex's Functional contributions
- Documentation = 15% ≈ (30% * 40%) = Symex's Documentation
- Promotion + Ease of adoption = 10% ≈ (30% * 30%) = Symex's Outreach
- Feel's like we're missing the "clos" implementation in the Clos form tree;
  if the "design example" includes implementation somehow, then I would reverse
  my weights.
- Odd numbers are hard
- `:set foldmethod=indent` is useful
